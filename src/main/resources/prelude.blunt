x == y  = primitiveOpEq (x,y)
x <  y  = primitiveOpLt (x,y)
x <= y  = primitiveOpLe (x,y)
x >  y  = primitiveOpGt (x,y)
x >= y  = primitiveOpGe (x,y)
x * y   = primitiveOpMultiply (x,y)
x / y   = primitiveOpDivide (x,y)
x + y   = primitiveOpPlus (x,y)
x - y   = primitiveOpMinus (x,y)
mod x y = primitiveMod (x,y)

data Boolean = True | False

data Maybe a = Just a
             | Nothing

nil? xs =
  case xs of
   [] -> True
   _  -> False

head xs =
  case xs of
   x:_ -> x
   []  -> error "can't get head of empty list"

tail xs =
  case xs of
   _:xs -> xs
   []   -> error "can't get tail of empty list"

id x = x

const x y = x

f . g = \x -> f (g x)

f $ x = f x

flip f x y = f y x

foldr f e xs =
  case xs of
     []   -> e
     x:xs -> f x (foldr f e xs)

foldl f e xs =
  case xs of
     []   -> e
     x:xs -> foldl f (f e x) xs

foldl1 f ls = foldr f (head ls) (tail ls)

sum = foldl (+) 0

product = foldl (*) 1

map f = foldr (\x y -> f x : y) []

filter p = foldr (\x xs -> if p x then x : xs else xs) []

reverse = foldl (flip (:)) []

length = foldl (\x y -> x + 1) 0

square x = x * x

range2 step min max =
  if min < max
    then min : (range2 step (min + step) max)
    else []

range = range2 1

x || y = if x then True else y

x && y = if x then y else False

not x = if x then False else True

and = foldr (&&) True

or = foldr (||) False

zero? x = x == 0

take n ls =
  if nil? ls || zero? n
    then []
    else head ls : take (n - 1) (tail ls)

drop n ls =
  if not (nil? ls) && n > 0
    then drop (n - 1) (tail ls)
    else ls

takeWhile p ls =
  case ls of
    []   -> []
    x:xs -> if p x then x : takeWhile p xs else []

dropWhile p ls =
  case ls of
    []   -> []
    x:xs -> if p x then dropWhile p xs else ls

all p = foldl (\x y -> p y && x) True

any p = foldl (\x y -> p y || x) False

xs ++ ys = foldr (:) ys xs

concat = foldr (++) []

concatMap f = concat . map f

curry f x y = f (x, y)

uncurry f p = f (fst p) (snd p)

zipWith f as bs =
  case as of
    []   -> []
    x:xs -> case bs of
              []   -> []
              y:ys -> f x y : zipWith f xs ys

zip = zipWith (\x y -> (x,y))

elem x = any ((==) x)

notElem x = not . elem x

span p ls = (takeWhile p ls, dropWhile p ls)

break p = span (not . p)

even? x = mod x 2 == 0

odd? = not . even?

x /= y = not (x == y)

min x y = if x < y then x else y

max x y = if x > y then x else y

minimum = foldl1 min

maximum = foldl1 max

sort ls =
  case ls of
    []   -> []
    x:xs -> sort (filter (\y -> y < x) xs) ++ [x] ++ sort (filter (\y -> y >= x) xs)

delete x xs =
  case xs of
    []   -> []
    y:ys -> if x == y then ys else y : delete x ys

(\\) = foldr delete

maybe e f m =
  case m of
    Just x  -> f x
    Nothing -> e
