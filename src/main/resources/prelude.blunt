(=) x y = primitiveOpEq (x,y);;
(<) x y = primitiveOpLt (x,y);;
(<=) x y = primitiveOpLe (x,y);;
(>) x y = primitiveOpGt (x,y);;
(>=) x y = primitiveOpGe (x,y);;
(*) x y = primitiveOpMultiply (x,y);;
(/) x y = primitiveOpDivide (x,y);;
(+) x y = primitiveOpPlus (x,y);;
(-) x y = primitiveOpMinus (x,y);;
(:) x y = primitiveCons (x,y);;

id x = x;;

const x y = x;;

compose f g x = f (g x);;

foldr f e ls =
  if nil? ls
    then e
    else f (head ls) (foldr f e (tail ls));;

sum = foldr (+) 0;;

product = foldr (*) 1;;

map f = foldr (\x y -> f x : y) [];;

filter p = foldr (\x xs -> if p x then x : xs else xs) [];;

length = foldr (\x y -> y + 1) 0;;

square x = x * x;;

range2 step min max =
  if min < max
    then min : (range2 step (min + step) max)
    else [];;

range = range2 1;;

(||) x y = if x then true else y;;

(&&) x y = if x then y else false;;

not x = if x then false else true;;

and = foldr (&&) true;;

or = foldr (||) false;;

zero? x = x = 0;;

take n ls =
  if nil? ls || zero? n
    then []
    else head ls : take (n - 1) (tail ls);;

drop n ls =
  if not (nil? ls) && n > 0
    then drop (n - 1) (tail ls)
    else ls;;

all p =
  foldr (\x y -> p x && y) true;;

any p =
  foldr (\x y -> p x || y) false;;

(++) xs ys =
  foldr (:) ys xs;;

concat =
  foldr (++) [];;

concatMap f =
  compose concat (map f);;

flip f x y = f y x;;

curry f x y = f (x, y);;

uncurry f p = f (fst p) (snd p);;
